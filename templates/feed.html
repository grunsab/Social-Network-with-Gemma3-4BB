{% extends "base.html" %}

{% block title %}Personalized Feed{% endblock %}

{% block content %}
<div class="container mt-4">
    <h2>Your Personalized Feed</h2>

    {% if interests %}
    <div class="alert alert-info" role="alert">
        <h5 class="alert-heading">Based on your interests:</h5>
        <p>{{ interests | join(', ') }}</p>
    </div>
    {% else %}
    <div class="alert alert-secondary" role="alert">
        No specific interests found yet. Showing recent posts. Like posts to personalize your feed!
    </div>
    {% endif %}

    <hr>

    {% if posts %}
        {% for post in posts %}
            <div class="card post-card shadow-sm mb-3">
                <div class="card-body">
                    <h5 class="card-title">
                        <a href="{{ url_for('profile', username=post.author.username) }}" class="text-decoration-none">@{{ post.author.username }}</a>
                        {% if post.privacy == PostPrivacy.FRIENDS %}
                            <span class="badge bg-info ms-2"><i class="bi bi-people-fill"></i> Friends Only</span>
                        {% elif post.privacy == PostPrivacy.PUBLIC %}
                            <span class="badge bg-secondary ms-2"><i class="bi bi-globe"></i> Public</span>
                        {% else %}
                            <span class="badge bg-dark ms-2">{{ post.privacy.name|title }}</span>
                        {% endif %}
                    </h5>
                     {% if post.image_url %}
                        <img src="{{ post.image_url }}" class="img-fluid rounded mb-2" alt="Post image" style="max-height: 400px; object-fit: cover;">
                    {% endif %}
                    {% if post.content %}
                        <div class="post-content mb-2" data-raw-content="{{ post.content|e }}">
                            <!-- Content will be rendered here by JavaScript -->
                        </div>
                    {% endif %}
                    <p class="card-text">
                        <small class="text-muted"><span class="local-timestamp" data-timestamp="{{ post.timestamp.isoformat() }}"></span></small>
                    </p>
                    {% if post.category_scores or post.classification_scores %}
                        <div class="mb-2">
                            {% set scores_to_display = post.category_scores or post.classification_scores %}
                            {% for score in scores_to_display|sort(attribute='score', reverse=True) %}
                                <span class="badge bg-secondary me-1">{{ score.category }} ({{ '%0.2f'|format(score.score) }})</span>
                            {% endfor %}
                        </div>
                    {% endif %}
                    <div class="d-flex flex-column align-items-start mt-2">
                        <div class="mb-2">
                            <button class="btn btn-sm btn-outline-primary comments-toggle" data-post-id="{{ post.id }}">
                                Comments <span class="comment-count">{# JS will update count #}</span>
                            </button>
                        </div>
                        {% if post.author == current_user %}
                            <div>
                                <form action="{{ url_for('delete_post', post_id=post.id) }}" method="POST" style="display: inline;" onsubmit="return confirm('Are you sure you want to delete this post?');">
                                    <input type="hidden" name="_method" value="DELETE">
                                    <button type="submit" class="btn btn-danger btn-sm">Delete</button>
                                </form>
                            </div>
                        {% endif %}
                    </div>
                    <div class="comments-section mt-3 border-top pt-3" id="comments-section-{{ post.id }}" style="display: none;">
                        <div class="comments-container" id="comments-container-{{ post.id }}">
                            <!-- Comments will be loaded here by AJAX -->
                            <div class="text-center">
                                <div class="spinner-border spinner-border-sm" role="status">
                                    <span class="visually-hidden">Loading...</span>
                                </div>
                            </div>
                        </div>
                        <form class="comment-form mt-3" data-post-id="{{ post.id }}">
                            <div class="input-group">
                                <input type="text" class="form-control comment-input" placeholder="Add a comment...">
                                <button class="btn btn-primary" type="submit">Post</button>
                            </div>
                        </form>
                    </div>
                </div>
            </div>
        {% endfor %}
    {% else %}
        <p>No posts found in your feed right now.</p>
    {% endif %}

</div>
{% endblock %}

{% block scripts %}
{{ super() }}
<script>
  document.addEventListener('DOMContentLoaded', function() {
    // Render markdown for post content
    const postContents = document.querySelectorAll('.post-content');
    postContents.forEach(div => {
      const rawContent = div.getAttribute('data-raw-content');
      if (rawContent) {
        // Configure marked to handle basic GFM line breaks
        marked.setOptions({
          breaks: true
        });
        // Use innerHTML as marked returns HTML string. Ensure content is properly escaped on server.
        div.innerHTML = marked.parse(rawContent);
      }
    });
    
    // --- Start: Comment Handling ---
    
    // Function to fetch and render comments
    function loadComments(postId, commentsSection, commentsContainer) {
      fetch(`/post/${postId}/comments`, {
        headers: {
          'X-Requested-With': 'XMLHttpRequest'
        }
      })
      .then(response => {
          if (!response.ok) { throw new Error('Network response was not ok'); }
          return response.json();
      })
      .then(comments => {
        let commentsHtml = '';
        const commentCountSpan = document.querySelector(`.comments-toggle[data-post-id="${postId}"] .comment-count`);

        if (comments.length === 0) {
          commentsHtml = '<div class="alert alert-light border-0 p-2 text-center">No comments yet. Be the first!</div>';
          if (commentCountSpan) commentCountSpan.textContent = ''; // Clear count
        } else {
          commentsHtml = '<div class="list-group list-group-flush">'; // Use flush for tighter spacing
          comments.forEach(comment => {
            commentsHtml += `
              <div class="list-group-item list-group-item-action flex-column align-items-start comment-item px-0 py-2" id="comment-${comment.id}">
                <div class="d-flex w-100 justify-content-between">
                  <h6 class="mb-1"><a href="/profile/${comment.author}" class="text-decoration-none">@${comment.author}</a></h6>
                  <small class="text-muted"><span class="local-timestamp" data-timestamp="${comment.timestamp}">Loading...</span></small>
                </div>
                <div class="comment-content mb-1"></div> {# Placeholder for markdown #}
                <div class="comment-raw-content" style="display: none;">${comment.content}</div> {# Store raw content #}
                ${comment.is_author ? 
                  `<div class="text-end mt-1">
                    <button class="btn btn-sm btn-outline-danger delete-comment" data-comment-id="${comment.id}" data-post-id="${postId}">Delete</button>
                   </div>` : ''}
              </div>
            `;
          });
          commentsHtml += '</div>';
          if (commentCountSpan) commentCountSpan.textContent = `(${comments.length})`; // Update count
        }
        
        commentsContainer.innerHTML = commentsHtml;

        // Render markdown for newly loaded comments
        renderCommentMarkdown(commentsContainer);
        
        // Format timestamps for newly loaded comments
        formatLocalTimestamps(commentsContainer);
        
        // Add event listeners for delete buttons WITHIN the specific container
        attachDeleteListeners(commentsContainer);
      })
      .catch(error => {
        console.error('Error loading comments:', error);
        commentsContainer.innerHTML = '<div class="alert alert-danger">Error loading comments.</div>';
        const commentCountSpan = document.querySelector(`.comments-toggle[data-post-id="${postId}"] .comment-count`);
        if (commentCountSpan) commentCountSpan.textContent = '(Error)';
      });
    }

    // Function to render markdown in comments
    function renderCommentMarkdown(container) {
        container.querySelectorAll('.comment-item').forEach(item => {
            const contentDiv = item.querySelector('.comment-content');
            const rawContentDiv = item.querySelector('.comment-raw-content');
            if (contentDiv && rawContentDiv) {
                 // Basic sanitization (replace with a proper library like DOMPurify if needed)
                 const sanitizedContent = rawContentDiv.textContent.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                 contentDiv.innerHTML = marked.parse(sanitizedContent || ''); // Use textContent
            }
        });
    }

    // Function to handle comment deletion
    function deleteComment(commentId, postId) {
        fetch(`/comment/${commentId}/delete`, {
            method: 'POST',
            headers: {
                'X-Requested-With': 'XMLHttpRequest'
            }
        })
        .then(response => {
             if (!response.ok) { throw new Error('Network response was not ok'); }
             return response.json();
        })
        .then(data => {
            if (data.success) {
                const commentElement = document.getElementById(`comment-${commentId}`);
                if (commentElement) {
                    commentElement.remove();
                }
                // Reload comments to update count and potentially show "no comments" message
                const commentsSection = document.getElementById(`comments-section-${postId}`);
                const commentsContainer = document.getElementById(`comments-container-${postId}`);
                if (commentsSection && commentsContainer && commentsSection.style.display !== 'none') {
                     loadComments(postId, commentsSection, commentsContainer);
                } else {
                     // If section is hidden, just update count if possible
                     const commentCountSpan = document.querySelector(`.comments-toggle[data-post-id="${postId}"] .comment-count`);
                     if (commentCountSpan) {
                         // Fetch count again or decrement (less accurate if others commented/deleted)
                         // Simplest is just to clear it or fetch again if needed elsewhere
                         commentCountSpan.textContent = ''; // Or trigger a recount
                     }
                }
            } else {
                alert('Error deleting comment.');
                console.error('Error deleting comment:', data);
            }
        })
        .catch(error => {
            alert('Error deleting comment.');
            console.error('Error:', error);
        });
    }

    // Function to attach delete listeners
    function attachDeleteListeners(container) {
         container.querySelectorAll('.delete-comment').forEach(button => {
              // Remove existing listener to prevent duplicates if re-attaching
              button.replaceWith(button.cloneNode(true));
         });
         // Add new listener
         container.querySelectorAll('.delete-comment').forEach(button => {
              button.addEventListener('click', function() {
                  const commentId = this.getAttribute('data-comment-id');
                  const postId = this.getAttribute('data-post-id');
                  if (confirm('Are you sure you want to delete this comment?')) {
                      deleteComment(commentId, postId);
                  }
              });
         });
    }
    
    // Handle comments toggle
    document.querySelectorAll('.comments-toggle').forEach(button => {
      button.addEventListener('click', function() {
        const postId = this.getAttribute('data-post-id');
        const commentsSection = document.getElementById(`comments-section-${postId}`);
        const commentsContainer = document.getElementById(`comments-container-${postId}`);
        
        if (commentsSection.style.display === 'none') {
          commentsSection.style.display = 'block';
          // Show loading spinner initially
          commentsContainer.innerHTML = `<div class="text-center"><div class="spinner-border spinner-border-sm" role="status"><span class="visually-hidden">Loading...</span></div></div>`;
          // Load comments via AJAX
          loadComments(postId, commentsSection, commentsContainer);
        } else {
          commentsSection.style.display = 'none';
        }
      });
    });
    
    // Handle comment form submission
    document.querySelectorAll('.comment-form').forEach(form => {
      form.addEventListener('submit', function(e) {
        e.preventDefault();
        const postId = this.getAttribute('data-post-id');
        const input = this.querySelector('.comment-input');
        const content = input.value.trim();
        const commentsSection = document.getElementById(`comments-section-${postId}`);
        const commentsContainer = document.getElementById(`comments-container-${postId}`);
        
        if (content && commentsSection && commentsContainer) {
           fetch(`/post/${postId}/comments`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
                'X-Requested-With': 'XMLHttpRequest'
              },
              body: `content=${encodeURIComponent(content)}`
            })
            .then(response => {
                if (!response.ok) { throw new Error('Network response was not ok'); }
                return response.json();
            })
            .then(comment => {
                input.value = ''; // Clear input
                // Reload comments to show the new one and update count
                loadComments(postId, commentsSection, commentsContainer);
            })
            .catch(error => {
                 alert('Error posting comment.');
                 console.error('Error posting comment:', error);
             });
        }
      });
    });
    
    // --- End: Comment Handling ---

    // Initial load for comment counts (Optional - loadComments handles counts now)
    /* 
    document.querySelectorAll('.comments-toggle .comment-count').forEach(span => {
         const button = span.closest('.comments-toggle');
         if (!button) return;
         const postId = button.getAttribute('data-post-id');
          fetch(`/post/${postId}/comments`, { headers: {'X-Requested-With': 'XMLHttpRequest', 'Accept': 'application/json'} })
             .then(response => response.ok ? response.json() : Promise.reject('Failed to load count'))
             .then(comments => { span.textContent = comments.length > 0 ? `(${comments.length})` : ''; })
             .catch(error => {
                 console.error(`Error fetching comment count for post ${postId}:`, error);
                 span.textContent = '(N/A)';
              });
     });
     */
     
  }); // End DOMContentLoaded
</script>
{% endblock %} 